                                   Eclipse Vert.x
........................................................................................................
Vert.x:
.......

What is Vertx?

Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.

Vertx is functional,event driven,object oriented,reactive,non blocking io and async tookit for building "distributed application - Micro service" on java virtual machine.

Vert.x is Polyglot tool kit for building micro services application.

Verx allows different programming languages can talk each other.


Polyglot means multi technology /language.

 Vertx supports Polyglot on jvm.

Does JVM support multi language(Polyglot)?

   Yes!.

2002,JCP published  specfication called "multi language" on jvm.
 
Groovy, was the first reference implementation of that spec 
Kotlin
Jython - python + java

Vetx PolyGlot

You can use Vert.x with multiple languages including Java, Kotlin, JavaScript, Groovy, Ruby and Scala.

Vert.x doesn't preach about what language is best â€” you choose the languages you want based on the task at hand and the skill-set of your team.

We provide idiomatic APIs for every language that Vert.x supports.


 How these languages works on jvm/
   jvm contract is only "byte code"

             groovy,kotlin,javascript,scala,ruby.......
	                |
                    compilers
                        |
                      .class
                        |
                       jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


java program and io:

os user space    |                            kernal

java api 
                                               File descriptor table
System.in ------c system call --------------- 0 ---keyboard

System.out------c system call ----------------1 ---monitor

Syste.err-------c system call-----------------2-----monitor

read file from disk:

 FileReader fr =new 
FileReader("C:]]test.txt");  ---c system call -------add new error into fd
                                              3--------Hard drive
  
 int i; 
 while ((i=fr.read()) != -1) ---------------c system call --------3------Harddrive
 System.out.print((char) i); 

 /////////////////////////////////////////////////////////////////////////////////////////////

How to reduce no of threads and at the same time how do you handle concurrent connections?

                   "Change Request per thread Archtecture".



Soultion : 

select + read apis togehter

fr.read()  ---------------------------------->|
           <---------------------------------

                                             data read
  make one more call-----------------------------
    <-----------------------------------------------------


apis to implement non blocking io:

1.select - first api but has it lot 
2.poll
3.epoll,kqueue,iocp


epoll:

It is a c program.
which has a loop ; infite loop;  for(;;) while(true)

//////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ibm.vertx.core;

import io.vertx.core.Vertx;

public class VertEngineCreation {
  public static void main(String[] args) {
    Vertx vertxEngine = Vertx.vertx();
    System.out.println(vertxEngine.getClass().getName());
  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////

How to write first Verticle and deploy them?

package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;

public class HelloWorld extends AbstractVerticle {

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Hello World Verticle");
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////

Deployment via coding: you dont need lanucher configuration in pom.xml
//////////////////////

Use case : Deploy the verticle itself via main method.

package com.ibm.vertx.core.deployments;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;

public class HelloWorldVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Vertx vertEngine = Vertx.vertx();
    //deploy on vertx Engine
    vertEngine.deployVerticle(new HelloWorldVerticle());
    vertEngine.close();
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Hello World Verticle");
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////////

How to deploy verticles from other plain java?


package com.ibm.vertx.core.deployments;

import io.vertx.core.AbstractVerticle;

public class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Greeter Verticle");
  }
}
package com.ibm.vertx.core.deployments;

import io.vertx.core.Vertx;

public class DeployerMain {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    //deploy greeter
    vertx.deployVerticle(new GreeterVerticle());
    //Verticle factory deployment
    vertx.deployVerticle(GreeterVerticle.class.getName());
    vertx.deployVerticle("com.ibm.vertx.core.deployments.GreeterVerticle");
  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
Deploy verticles from another verticle? inside start method


 MainVerticle
    |
    deploy
         |
          start----you can deploy other verticles.


How to deploy main verticle?

 -Via - maven pom.xml
 -Via - Launcher -vertx run
 -Via- Programetic Launcher- later
 -Via - Runner class- provided by vertx team.



package com.ibm.vertx.core.deployments;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.example.util.Runner;

public class MainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
//     Vertx vertx = Vertx.vertx();
//     vertx.deployVerticle(new MainVerticle());
    Runner.runExample(MainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Main verticle");
    vertx.deployVerticle(new GreeterVerticle());
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////

Threading model in vertx:

Vert x and Event loop:

Vertx process events comming from kernal space , via event loop, still it is while loop but that loop bound to a thread , that thread is called event loop thread.

Every verticle by default is bound to a thread Event loop thread.

Verticle can handle events and process them.

How many event loops are there in vertx?

In node js , only one event loop.

In vertx per cpu core 2 event loops.

eg , if i have 12 cores - 24 event loop.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Eg : Knowing the threads:

Note: every verticle by default bound with a thread - event loop thread
if no of verticles increases, vertx assigns each verticle with one thread. 
a single thread can bound with many verticles.


package com.ibm.vertx.core.deployments;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

class MyVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("My verticle " + Thread.currentThread().getName());
  }
}


public class EventLoopThreadMainVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(EventLoopThreadMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Main Verticle " + Thread.currentThread().getName());
    for (int i = 1; i <= 25; i++)
      vertx.deployVerticle(new MyVerticle());
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

How to process events 

-Verticle
-Event loop Thread
-Event handlers

Vertx Event Handlers can be in written in two ways

1.Future && Promise Pattern : Functional/callback style
2.Reactive Pattern - RxJava2


if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".



1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop starts processing.

What is handler function/callback function/listener function for?
To handle async success /failure result.
   The result of async opertion could be either success or failure

////////////////////////////////////////////////////////////////////////////////////////////////////////

io.vertx.Future:

-it is interface used to handle async success/failure results.

io.vertx.core

Future Interface 
				AsyncResult       Handler
				-------------------------
					   |
				         Future



Future interface is used to handle the result of async operation.


Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation

 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.


Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure

AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success


Future Object creation and encaspulating data

1.Future future = Future.future()
 future.complete(T value)
 future.fail(T value)

2.static factory api
Future.succeedFuture(T value)
  Future.FailedFuture(T value)

3.function as parameter pattern ; callback pattern

package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;

class MessageServiceVerticle extends AbstractVerticle {

  //apis to send data via future;

  //send empty response
  public Future<Void> getEmptyMessage() {
    //Create Future Object
    Future<Void> future = Future.future();
    //encapsulate response
    future.complete();
    //return the fututure , so that somebody can handle.
    return future;
  }

  //send simple success response only
  public Future<String> getSuccessMessage() {
    //Create Future Object
    Future<String> future = Future.future();
    //encapsulate response
    future.complete("Hello,I am Future");
    //return the fututure , so that somebody can handle.
    return future;
  }

  //send simple error response only
  public Future<String> getErrorMessage() {
    //Create Future Object
    Future<String> future = Future.future();
    //encapsulate response
    future.fail("Something went wrong!!");
    //return the fututure , so that somebody can handle.
    return future;
  }

  //how to send success or error message based on logic
  public Future<String> getGreetingMessage() {
    //Create Future Object
    Future<String> future = Future.future();
    //encapsulate response
    String message = "hello";
    if (message.equals("hello")) {
      future.complete("Yes Hello Message i got it");
    } else {
      future.fail(new RuntimeException("No, i did not get any message"));
    }

    //return the fututure , so that somebody can handle.
    return future;
  }

  //create Future object using factory apis
  public Future<String> getHelloMessage() {
    //encapsulate response
    String message = "hello";
    if (message.equals("hello")) {
      return Future.succeededFuture("Yes Hello Message i got it");
    } else {
      return Future.failedFuture(new RuntimeException("No, i did not get any message"));
    }
  }

  //create Future object and encapulate via function as parameter
  public void getHaiMessage(Handler<AsyncResult<String>> aHandler) {
    String message = "hai";
    if (message.equals("hai")) {
      //create Future object and encapsulate data
      aHandler.handle(Future.succeededFuture("Yes Hello Message i got it"));
    } else {
      aHandler.handle(Future.failedFuture(new RuntimeException("No, i did not get any message")));
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //handler
    if (getEmptyMessage().succeeded()) {
      System.out.println("Empty message");
    }
    //handler attachment ; we have more handler attachment api
    getSuccessMessage().onComplete(new Handler<AsyncResult<String>>() {
      @Override
      public void handle(AsyncResult<String> asyncResult) {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result());
        } else {
          System.out.println(asyncResult.cause());
        }
      }
    });
    getSuccessMessage().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    getSuccessMessage().onSuccess(response -> System.out.println(response));
    getSuccessMessage().onSuccess(System.out::println);
    ////////////////////////////////////////////////////////////////////////////
    getErrorMessage().onComplete(asyncResult -> {
      if (asyncResult.failed()) {
        System.out.println(asyncResult.cause());
      }
    });
    getErrorMessage().onFailure(errors -> System.out.println(errors));
    getErrorMessage().onFailure(System.out::println);
    ////////////////////////////////////////////////////////////////////////////////////////////////

    getGreetingMessage().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    getGreetingMessage()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    ////////////////////////////////////////////////////////////////////////////////////////////////
    getHelloMessage()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    //////////////////////////////////////////////////////////////////////////////////////////////////
    //function as parameter
    getHaiMessage(response -> {
      if (response.succeeded()) {
        System.out.println("Got Response" + response.result());
      } else {
        System.out.println("Got Error Response " + response.cause());
      }
    });


  }
}

public class FutureAppMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FutureAppMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new MessageServiceVerticle());
  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

Promises:

Async Wrapper Object : Promise:
...............................

Promise is async abstraction largly promoted by javascript community.

Dont Compare  javascript Promises with Vertx Promises , because both are different.

Promise is "semantically meaningfull abstraction" for handling asyn results.

Many times developers confuse with java Future and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis.

Promises must be converted into Future before processing.


class MessagePromiseServiceVerticle extends AbstractVerticle {
  //send simple success response only
  public Future<String> getSuccessMessage() {
    //Create Promise Object
    Promise<String> promise = Promise.promise();
    //encapsulate response
    promise.complete("Hello,I am Promise");
    //return the fututure , so that somebody can handle.
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
//    getSuccessMessage().future().onComplete(asyncResult -> {
//      if (asyncResult.succeeded()) {
//        System.out.println(asyncResult.result());
//      }
//    });
    getSuccessMessage().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      }
    });
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Legacy Application flow : object oriented and sync flow
  
dependent operations  , should happen one by one

Object oriented seq work flow

 1.connect db - connect()
 2.Query results -queryResult()
 3.Formate results -formateResult()
 4.add results into http response stream - write()
 5.send/flush the results to clients - send()

 Connection con=DriverManager.getConnection("connectionstring");
 QueryResult queryres=con.queryResult()
 List<T> results = formatResult(queryres)
 response.write(results)
 reponse.end();
 .......................................................................................

How to implement sequential work flow in functional programming: Vert.X:
.........................................................................

Functional sequential workflow:

 Nested Callback : Callback chaining: functional style

  Handler function is called as callback function

"The out put of one callback is input to the another callback : nested callbacks

   cb1
     --cb2
         -cb3
            --cbN
              --process the result.



package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class UserServiceVerticle extends AbstractVerticle {

  public Future<String> getUser() {
    Promise<String> promise = Promise.promise();
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail(new RuntimeException("User not found"));
    }
    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise<String> promise = Promise.promise();
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail(new RuntimeException("login failed"));
    }
    return promise.future();
  }

  public Future<String> showPage(String loginStatus) {
    Promise<String> promise = Promise.promise();
    if (loginStatus.equals("login successxx")) {
      promise.complete("You are admin");
    } else {
      promise.fail(new RuntimeException("You are guest"));
    }
    return promise.future();
  }


  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(userAsyncResult -> {
      if (userAsyncResult.succeeded()) {
        System.out.println("Get user is called");
        //call login method
        login(userAsyncResult.result()).onComplete(loginuserAsyncResult -> {
          System.out.println("login is called");
          if (loginuserAsyncResult.succeeded()) {
            System.out.println("show page is called");
            showPage(loginuserAsyncResult.result()).onComplete(pageuserAsyncResult -> {
              if (pageuserAsyncResult.succeeded()) {
                System.out.println(pageuserAsyncResult.result());
              } else {
                System.out.println(pageuserAsyncResult.cause());
              }
            });
          } else {
            System.out.println(loginuserAsyncResult.cause());
          }
        });
      } else {
        System.out.println(userAsyncResult.cause());
      }
    });
  }
}


public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserServiceVerticle());
  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
callback Hell:
 The way we write nested callbacks.
 doom of pyrmid

    getUser().onComplete(userasync -> {
      if (userasync.succeeded()) {
        System.out.println("getUser is called");
        login(userasync.result()).onComplete(loginasync -> {
          if (loginasync.succeeded()) {
            System.out.println("login is called");
            showPage(loginasync.result()).onComplete(pageasync -> {
              System.out.println("get page is called");
              if (pageasync.succeeded()) {
                System.out.println(pageasync.result());
              } else {
                System.out.println(pageasync.cause());
              }
            });
          } else {
            System.out.println(loginasync.cause());
          }
        });
      } else {
        System.out.println(userasync.cause());
      }
    });

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!

This is called callback hell; The callback hell is way of writing complex callbacks.



can we escape from callback hell problem, how to write better callback based programming?

Yes! 


Solution to callback Hell:
..........................
compose method of Future & Promise 

package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class UserVerticle extends AbstractVerticle {

  public Future<String> getUser() {
    System.out.println("Get user is called");

    Promise<String> promise = Promise.promise();
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail(new RuntimeException("User not found"));
    }
    return promise.future();
  }

  public Future<String> login(String userName) {
    System.out.println("login is called");
    Promise<String> promise = Promise.promise();
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail(new RuntimeException("login failed"));
    }
    return promise.future();
  }

  public Future<String> showPage(String loginStatus) {
    System.out.println("show page is called");
    Promise<String> promise = Promise.promise();
    if (loginStatus.equals("login success")) {
      promise.complete("You are admin");
    } else {
      promise.fail(new RuntimeException("You are guest"));
    }
    return promise.future();
  }

  //callback hell code
  public void processUsingCallbackHell() {
    getUser().onComplete(userAsyncResult -> {
      if (userAsyncResult.succeeded()) {
        System.out.println("Get user is called");
        //call login method
        login(userAsyncResult.result()).onComplete(loginuserAsyncResult -> {
          System.out.println("login is called");
          if (loginuserAsyncResult.succeeded()) {
            System.out.println("show page is called");
            showPage(loginuserAsyncResult.result()).onComplete(pageuserAsyncResult -> {
              if (pageuserAsyncResult.succeeded()) {
                System.out.println(pageuserAsyncResult.result());
              } else {
                System.out.println(pageuserAsyncResult.cause());
              }
            });
          } else {
            System.out.println(loginuserAsyncResult.cause());
          }
        });
      } else {
        System.out.println(userAsyncResult.cause());
      }
    });
  }

  //soultion to callback
  public void compose() {

    getUser().compose(userName -> {
      return login(userName);
    }).compose(loginStatus -> {
      return showPage(loginStatus);
    }).onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    //refactoring
    getUser()
      .compose(this::login)
      .compose(this::showPage)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }


  @Override
  public void start() throws Exception {
    super.start();
    compose();


  }
}

public class CallbackHellSoution extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackHellSoution.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Data Format in vertx:

1.Buffer
2.JSON object

Buffer
JSON


Buffer:

1.Verticles running in vertx often need to process blocks of data.
2.For instance , data from an incomming http request, data loaded from the disk or data generated as response to http request etc.
3.A Buffer in vertx can hold binary data.
4.Buffer is similar to byte array, except the buffer can expand its capacity dynamically  as you write data to it.


package com.ibm.vertx.core.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;

public class BufferMainVerticle  extends AbstractVerticle{
  public static void main(String[] args) {
    Runner.runExample(BufferMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    Buffer buffer = Buffer.buffer();
    buffer.appendString("Hello");
    buffer.appendString("Hai");
    buffer.appendString("Welcome");
    buffer.appendString("How are you");
    buffer.appendString("this is binary data");
    System.out.println(buffer.length());
    System.out.println(buffer.toString());
  }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////

JSON: Data interchange format ; used heavily inside vertx.

JsonObject
JsonArray
Json - parser /mapper

Are you fluent? ; it is pattern  to create object ;

old style;
JsonObject user = new JsonObject();
    user.put("id",1);
    user.put("name","Subramanian");
    user.put("status",true);
   
fluent style




package com.ibm.vertx.core.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.Json;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

import java.util.ArrayList;
import java.util.List;

class Address {
  private String city;

  public Address() {
    this.city = "Coimbaotre";
  }

  public String getCity() {
    return city;
  }

  public void setCity(String city) {
    this.city = city;
  }

  @Override
  public String toString() {
    return "Address{" +
      "city='" + city + '\'' +
      '}';
  }

}

class User {
  private int id;
  private String name;

  private List<String> skills = new ArrayList<>();
  private Address address;

  public User() {
    this.id = 1;
    this.name = "default";
    this.skills.add("java");
    this.skills.add("vertx");
    this.address = new Address();
  }

  public Address getAddress() {
    return address;
  }

  public void setAddress(Address address) {
    this.address = address;
  }

  public List<String> getSkills() {
    return skills;
  }

  public void setSkills(List<String> skills) {
    this.skills = skills;
  }

  public int getId() {
    return id;
  }

  public void setId(int id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @Override
  public String toString() {
    return "User{" +
      "id=" + id +
      ", name='" + name + '\'' +
      ", skills=" + skills +
      ", address=" + address +
      '}';
  }
}


public class JsonObjectVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JsonObjectVerticle.class);
  }

  public void createJsonObject() {
    JsonObject user = new JsonObject();
    user.put("id", 1);
    user.put("name", "Subramanian");
    user.put("status", true);
    System.out.println(user.getInteger("id") + " " + user.getString("name") + " " + user.getBoolean("status"));
    System.out.println(user.encode());
    System.out.println(user.encodePrettily());
    //fulent pattern; builder ; "hello".trim().toUpperCase();
    JsonObject user2 = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true);
    System.out.println(user2.encodePrettily());

    //nested Object
    JsonObject user3 = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true)
      .put("address", new JsonObject().put("city", "Coimbatore").put("state", "Tamil Nadu"));
    System.out.println(user3.encodePrettily());
    System.out.println(user3.getJsonObject("address").encodePrettily());

    //merging two json into one.
    JsonObject appConfig = new JsonObject().put("appName", "Elearn").put("version", "1.0.0");
    JsonObject serverConfig = new JsonObject().put("http.host", "localhost").put("http.port", 8080);

    JsonObject config = new JsonObject()
      .put("author", "subramanian")
      .mergeIn(serverConfig)
      .mergeIn(appConfig);
    System.out.println(config.encodePrettily());

  }

  //create JSON ARRAY
  public void createJsonArray() {
    JsonArray products = new JsonArray()
      .add(new JsonObject().put("id", 1).put("price", 10))
      .add(new JsonObject().put("id", 2).put("price", 90))
      .add(new JsonObject().put("id", 3).put("price", 60))
      .add(new JsonObject().put("id", 4).put("price", 50));
    System.out.println(products.encodePrettily());
  }

  public void createJsonFromObject() {
    //Create Json from java Object
    String result = Json.encode(new User());
    System.out.println(result);
    JsonObject user = new JsonObject(result);
    System.out.println(user.encodePrettily());
    User myUser = Json.decodeValue(result, User.class);
    System.out.println(myUser.toString());
  }
  }

  //Promise & Future with json
  public Future<JsonObject> getUser() {
    Promise<JsonObject> promise = Promise.promise();
    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("status", true)
      .put("address", new JsonObject().put("city", "Coimbatore").put("state", "Tamil Nadu"));
    promise.complete(user);
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    //createJsonObject();
    //createJsonArray();
    createJsonFromObject();
  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
Non blocking apis:

->Creating TCP clients and servers
->Creating HTTP clients and servers
->Creating DNS clients
->Creating Datagram sockets
->Setting and cancelling periodic and one-shot timers
->Getting a reference to the event bus API
->Getting a reference to the file system API

if you want to create non blocking apps, vertx instance offers all apis.

Styles of writing non blocking code.

1.inside verticle
   using vertx.nonBlockingXXxapi();
2.without verticle 
   inside normal java program.

if you want to write non blocking apps  , you dont need verticles. verticles are optional but
in realtime applications verticles are neccessary.

Note:
   All non blocking apis are handled by "event loop threads" only.

Apis :

 -Timer
 -Event Bus
 -HttpServers
 -Jdbc
 -Mongodb

Timers are used to delay some operations.

package com.ibm.vertx.core.async.timers;

import io.vertx.core.*;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

import java.util.Date;

public class TimersVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimersVerticle.class);
  }

  public void blockMe(String message) {
    System.out.println(message);
  }

  public void delay(long timeout) {
    //non blocking api
    vertx.setTimer(timeout, asynHandler -> {
      //logic for timer
      System.out.println("I am ready after " + timeout);
    });
  }

  //getasyn
  public Future<JsonObject> getAsynMessage(long timeout) {
    Promise<JsonObject> promise = Promise.promise();
    vertx.setTimer(timeout, asynHandler -> {
      JsonObject jsonObject = new JsonObject().put("message", "Hello");
      promise.complete(jsonObject);
    });
    return promise.future();
  }

  public void tick(long timeout, Handler<AsyncResult<String>> aHandler) {
    long timerId = vertx.setPeriodic(timeout, han -> {
      aHandler.handle(Future.succeededFuture(new Date().toString()));
    });
    //stopping timer
    vertx.setTimer(10000, myHandler -> {
      System.out.println("Stopping emitting Date values");
      vertx.cancelTimer(timerId);
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    blockMe("start");
    delay(1000);
    getAsynMessage(2000).onComplete(jsonObjectAsyncResult -> {
      if (jsonObjectAsyncResult.succeeded()) {
        System.out.println(jsonObjectAsyncResult.result().encodePrettily());
      }
    });
    tick(1000, response -> {
      if (response.succeeded()) {
        System.out.println(response.result());
      }
    });
    blockMe("end");
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
Micro service Development
.........................

What are microservices?
  Microservices - also known as the microservice architecture , it is style of building distributed
applications.

Vertx has been designed from ground level to adopt microservices archtietectural patterns.

Service:
  It represents biz capablity.
  Having biz logic.
  Services are highly loosly coupled objects /compoents
  Services has been designed to communitate with other services locally, and also remotly.

Service in vertx represents verticles.

Verticles can communicate
 within system
 across system.
 across other system.

Verticle communcation patterns:
................................

1.message oriented style
2.http oriented style.

other styles also availble.


1.message oriented style :Event Bus

Event Bus:

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.
-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer


How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern




How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon

///////////////////////////////////////////////////////////////////////////////////////////////////////

How to get Event Bus Object?

EventBus mybus =  vertx.eventBus();

starting send message

mybus.send
mybus.publish
mybus.request


receiving
mybus.handler


package com.ibm.vertx.microservices.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;

package com.ibm.vertx.microservices.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;

//pub-sub; one to many; one message can be delivered to many vertilces at  a time.
class Address {
  public final static String PUB_SUB_ADDRESS = "news.in.covid";
  public final static String POINT_TO_POINT = "covid.fin.request";
  public final static String REQUEST_REPLY = "covid.lab.report";
}

class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply("Patient is Crictal, Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class ReportVerticle extends AbstractVerticle {

  public void sendReport() {
    vertx.setTimer(5000, ar -> {
      String message = "Report of Mr.x";
      vertx.eventBus().request(Address.REQUEST_REPLY, message, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
        } else {
          System.out.println(asyncResult.cause());
        }
      });
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    sendReport();
  }
}


/////////////////////////////////////////////////////////////////////////////////////////////
class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 1 -  : " + news.body());
    });
  }

  public void consume2() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request 2 -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
    consume2();
  }
}




class FinanceRequestVerticle extends AbstractVerticle {

  public void requestFinance() {
    System.out.println("Finance Request started....");
    vertx.setTimer(5000, ar -> {
      //point to point : send method
      String message = "Dear Team, We request that we want 1 Billion Money for Covid";
      //point to point ; send
      vertx.eventBus().send(Address.POINT_TO_POINT, message);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    requestFinance();
  }
}







///////////////////////////////////
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println(this.getClass().getSimpleName() + " " + message.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

//publisher publish news to all news tv channels
class PublisherVerticle extends AbstractVerticle {

  public void publish() {
    //one to many
    EventBus eventBus = vertx.eventBus();
    String message = "In India more than 80 lakh people affected covid";
    //publish inside timer
    vertx.setTimer(5000, h -> {
      System.out.println("Started Publishing message.....");
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    publish();
  }
}


public class EventBusVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusVerticle.class);
  }

  public void pubsub() {
    vertx.deployVerticle(new PublisherVerticle());
    vertx.deployVerticle(new NDTVVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
  }
  public void pointToPoint() {
    vertx.deployVerticle(new CenertalFinanceVerticle());
    vertx.deployVerticle(new FinanceRequestVerticle());
  }
  public void requestReply() {
    vertx.deployVerticle(new ReportVerticle());
    vertx.deployVerticle(new LabVerticle());
  }

  @Override
  public void start() throws Exception {
    super.start();
//    pubsub();
//    pointToPoint();
    requestReply();
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////

Web App development in vertx:

Vertx is fully powered with non blocking apis.
Vertx supports http prototcal to build non blocking web apps.

Modules In web space:

1.vertx core http module.
2.vertx-web module - It is minialistic framework to build realtime Webservices and dynamic web apps
3.vertx-webclient -  Service interaction api via  http Protocal


HTTP Core module Object:

1.HttpServer
   -Used to build web containers
   -Used to handle incomming request and sending response.
2.HttpServerRequest
   -Object used to handle incoming request
   -has api called response() to get Resonse Object
3.HttpServerResponse
   -Object used to send resonse to clients


package com.ibm.vertx.microservices.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class SimpleHTTPServerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleHTTPServerVerticle.class);
  }

  public void createHttpServer() {
    //server creaton
    HttpServer server = vertx.createHttpServer();
    //request handler
    server.requestHandler(request -> {
      //handle client request
      HttpServerResponse response = request.response();
      response.end("Hello ,Vertx Web Server");
    });
    //start web container
    server.listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server has failed to start");
      }
    });
  }

  public void createHttpServerFluentPattern() {

    vertx.createHttpServer()
      .requestHandler(request -> {
        request.response().end("Hello ,Vertx Web Server");
      })
      .listen(3000, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
        } else {
          System.out.println("Server has failed to start");
        }
      });


  }

  @Override
  public void start() throws Exception {
    super.start();
   createHttpServerFluentPattern();

  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////

Read Input :
package com.ibm.vertx.microservices.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class HttpServerRequestAndResponse extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HttpServerRequestAndResponse.class);
  }

  public void readRequest() {
    vertx.createHttpServer().requestHandler(request -> {
      //read request
      request.bodyHandler(buffer -> {
        System.out.println(buffer.toString());
      }).response().end("i got body");
      

    }).listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server has failed to start");
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    readRequest();

  }
}
///////////////////////
 public void sendJson() {
    vertx.createHttpServer().requestHandler(request -> {
      //send json
      JsonObject message = new JsonObject().put("message", "Hello how are you");
      request.response()
        .setStatusCode(200)
        .putHeader("content-type", "application/json")
        .end(message.encodePrettily());

    }).listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server has failed to start");
      }
    });
  }


/////////////////////////
read json
public void readJson() {
    vertx.createHttpServer().requestHandler(request -> {
      //read request
      request.bodyHandler(buffer -> {
        JsonObject jsonObject = buffer.toJsonObject();
        System.out.println(jsonObject.getString("message"));
        System.out.println(jsonObject.encodePrettily());
        request.response().end(jsonObject.getString("message"));
      });

    }).listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server has failed to start");
      }
    });
  }
//////////////////////////////////////////////////////////////////////////////////////////////////////
I WANT TO build REST End point :


URL - resource mapping
 /api/resource
 
METHOD -  GET ,POST,PUT,DELETE....


  public void buildREST() {
    vertx.createHttpServer().requestHandler(request -> {
      //URL MAPPING AND METHOD MAPPING
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.GET) {
        request.response().setStatusCode(200).end("users-GET");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.POST) {
        request.response().setStatusCode(200).end("users-POST");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.PUT) {
        request.response().setStatusCode(200).end("users-PUT");
      }
    }).listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server has failed to start");
      }
    });
  }

Have a look at the above, notice the drawbacks.

-The developer write all method and resource mapping logic
-There is no proper modularity in build ing apps.

Soultion:

Vertx provides a small framework for abstracting these things
vertx-web

Core features of vertx-Web:

1.modularized apis using Routers.

A Router is one of the core concepts of Vert.x-Web.
Itâ€™s an object which maintains zero or more Routes .

A router takes an HTTP request and finds the first matching route for that request, and passes the request to that route.

The route can have a handler associated with it, which then receives the request.
You then do something with the request, and then, either end it or pass it to the next matching handler.

Before vertx-web, and Router you have to dump all the request handling code inside requestHandler.

Old style:
..........
HttpServer server = vertx.createHttpServer();
server.requestHandler(request -> {
  // This handler gets called for each request that arrives on the server
  HttpServerResponse response = request.response();
  response.putHeader("content-type", "text/plain");

  // Write to the response and end it
  response.end("Hello World!");
});

server.listen(8080);

/////////////////////////////////////////////////////////////////////////////////////////////////////

Vertx-Web core Objects:
........................

1.Router
2.Route
3.RoutingContext

Router has collection of Routes

Each Route represents method mapping and url mapping.

RoutingContext is container object similar to ServletContext in Servlet.

Using RoutingContext 
  - You can get request object
  - YOu can get reponse object

package com.ibm.vertx.microservices.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

public class SimpleRouter extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleRouter.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //create Router object
    Router router = Router.router(vertx);
    //http get method with url
//    Route route1 = router.get("/api/message/hello");
//    route1.handler(routingContext -> {
//      routingContext.response().end("Hello");
//    });
//    router.get("/api/message/hello")
//      .handler(routingContext -> {
//        routingContext.response().end("Hello");
//      });
//    router.get("/api/message/hai")
//      .handler(routingContext -> {
//        routingContext.response().end("Hai");
//      });
//    router.get("/api/message/greet")
//      .handler(routingContext -> {
//        routingContext.response().end("Greet");
//      });
     router.get("/api/message/hello")
      .handler(routingContext -> {
        routingContext.response().end("Hello");
      });
    router.get("/api/message/hai")
      .handler(routingContext -> {
        routingContext.response().end("Hai");
      });
    router.get("/api/message/greet")
      .handler(routingContext -> {
        routingContext.response().end("Greet");
      });
    vertx.createHttpServer().requestHandler(router).listen(3000, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("server is running at " + httpServerAsyncResult.result().actualPort());
      } else {
        System.out.println("Server has failed to start");
      }
    });


  }

}
///////////////////////////////////////////////////////////////////////////////////////////////////////

REST FULL Web Services:

-in memory data source.
.......................
package com.ibm.vertx.microservices.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

import java.util.HashMap;
import java.util.Map;

public class ProductApplication extends AbstractVerticle {
  //products-db
  private Map<String, JsonObject> products = new HashMap<>();

  public static void main(String[] args) {
    Runner.runExample(ProductApplication.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    setUpInitialData();

    Router productRouter = Router.router(vertx);
    //global settings for application; body handler ; to read entire body.
    //vertx will execute this handler for every in flight request.
    productRouter.route().handler(BodyHandler.create());

    productRouter.get("/").handler(this::handleListProducts);
    productRouter.get("/:productID").handler(this::handleGetProduct);
    //post / create product;
    productRouter.post("/create").handler(this::handleAddProduct);

    //update a existing product
    productRouter.put("/:productID").handler(this::handleUpdateProduct);
    //delete existing product
    productRouter.delete("/:productID").handler(this::handleDeleteHandler);


    vertx.createHttpServer().requestHandler(productRouter)
      .listen(3000, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("Products Server is Running " + httpServerAsyncResult.result().actualPort());
        }
      });
  }

  private void handleDeleteHandler(RoutingContext routingContext) {
    String productID = routingContext.request().getParam("productID");
    HttpServerResponse response = routingContext.response();
    if (productID == null) {
      sendError(400, response);
    } else {
      products.remove(productID);
      JsonArray arr = new JsonArray();
      products.forEach((k, v) -> arr.add(v));
      routingContext.response().putHeader("content-type", "application/json").end(arr.encodePrettily());
    }
  }

  private void handleUpdateProduct(RoutingContext routingContext) {
    String productID = routingContext.request().getParam("productID");
    HttpServerResponse response = routingContext.response();
    if (productID == null) {
      sendError(400, response);
    } else {
      JsonObject product = routingContext.getBodyAsJson();
      System.out.println(product);
      if (product == null) {
        sendError(400, response);
      } else {
        products.put(productID, product);
        JsonArray arr = new JsonArray();
        products.forEach((k, v) -> arr.add(v));
        routingContext.response().putHeader("content-type", "application/json").end(arr.encodePrettily());
      }
    }
  }

  private void handleAddProduct(RoutingContext routingContext) {
    // clients send input as json(String),inside application; we need to parse into JsonObject
    //read payload(body) from request object.
    JsonObject product = routingContext.getBodyAsJson();
    System.out.println(product);
    addProduct(product);
    JsonArray arr = new JsonArray();
    products.forEach((k, v) -> arr.add(v));
    routingContext.response()
      .putHeader("content-type", "application/json")
      .end(arr.encodePrettily());
  }

  private void handleGetProduct(RoutingContext routingContext) {
    String productID = routingContext.request().getParam("productID");
    HttpServerResponse response = routingContext.response();
    if (productID == null) {
      //send error
      sendError(400, response);
    } else {
      JsonObject product = products.get(productID);
      if (product == null) {
        // sendError(404, response);
        sendError(400, response);
      } else {
        response.putHeader("content-type", "application/json")
          .setStatusCode(200)
          .end(product.encodePrettily());
      }
    }

  }

  private void sendError(int statusCode, HttpServerResponse response) {
    response.setStatusCode(statusCode).end();
  }


  private void handleListProducts(RoutingContext routingContext) {
    JsonArray arr = new JsonArray();
    products.forEach((k, v) -> arr.add(v));
    routingContext.response()
      .putHeader("content-type", "application/json")
      .setStatusCode(200)
      .end(arr.encodePrettily());
  }


  private void setUpInitialData() {
    addProduct(new JsonObject().put("id", "prod3568").put("name", "Egg Whisk").put("price", 3.99).put("weight", 150));
    addProduct(new JsonObject().put("id", "prod7340").put("name", "Tea Cosy").put("price", 5.99).put("weight", 100));
    addProduct(new JsonObject().put("id", "prod8643").put("name", "Spatula").put("price", 1.00).put("weight", 80));
  }

  private void addProduct(JsonObject product) {
    products.put(product.getString("id"), product);
  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

What if i have more resources and more routes?

ProductRouter - /api/products
UserRouter -  /api/users
Payment Router - /api/payment

server.requestHandler(?);

SubRouters and Main routers

- you can have more subrouters - prodct,user,payment..
-  you can have only one main /app router -  approuter
- that app router only can passed to requestHandler(appRouter).

How to bind /connect app router with subrouter

Router has method called "mountSubRouter"


package com.ibm.vertx.microservices.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class BigRouterApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BigRouterApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    Router productRouter = Router.router(vertx);
    Router userRouter = Router.router(vertx);
    Router accountRouter = Router.router(vertx);
    Router appRouter = Router.router(vertx);
    ///routes
    productRouter.get("/").handler(routingContext -> {
      routingContext.response().end("proudcts list");
    });
    userRouter.get("/").handler(routingContext -> {
      routingContext.response().end("User list");
    });
    accountRouter.get("/").handler(routingContext -> {
      routingContext.response().end("Acount list");
    });
    //mount/bind app with sub routers
    appRouter.route().handler(BodyHandler.create());
    appRouter.mountSubRouter("/api/products", productRouter);
    appRouter.mountSubRouter("/api/users", userRouter);
    appRouter.mountSubRouter("/api/accounts", accountRouter);

    vertx.createHttpServer().requestHandler(appRouter)
      .listen(3000, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("Products Server is Running " + httpServerAsyncResult.result().actualPort());
        }
      });

  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

Verticle communications:

-message driven - event bus
-http driven  -  WebClient


package com.ibm.vertx.microservices.web.client;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.WebClient;
import io.vertx.ext.web.handler.BodyHandler;

class ProviderVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    Router router = Router.router(vertx);

    router.route().handler(BodyHandler.create());

    router.get("/api/message/:message").handler(routingContext -> {
      String message = routingContext.request().getParam("message");
      routingContext.response().end(message);
    });
    //post
    router.post("/api/message/create").handler(routingContext -> {
      System.out.println(routingContext.getBodyAsJson());
      routingContext.response().end("Created");
    });

    vertx.createHttpServer()
      .requestHandler(router)
      .listen(3000, httpServerAsyncResult -> {
        if (httpServerAsyncResult.succeeded()) {
          System.out.println("Provider Verticle Server is Running " + httpServerAsyncResult.result().actualPort());
        }
      });
  }
}

class ConsumerVerticle extends AbstractVerticle {
  WebClient webClient;

  @Override
  public void start() throws Exception {
    super.start();
    //create webclient object
    webClient = WebClient.create(vertx);
    Router router = Router.router(vertx);

    router.get("/:message").handler(routingContext -> {
      String message = routingContext.request().getParam("message");
      //webclient
      webClient
        .get(3000, "localhost", "/api/message/" + message)
        .send(httpResponseAsyncResult -> {
          if (httpResponseAsyncResult.succeeded()) {
            routingContext.response().setStatusCode(200).end(httpResponseAsyncResult.result().bodyAsString());
          }
        });
    });

    router.post("/create").handler(routingContext -> {
      JsonObject user = new JsonObject()
        .put("firstName", "Subramanian")
        .put("lastName", "Murugan")
        .put("male", true);
      //webclient
      webClient
        .post(3000, "localhost", "/api/message/create")
        .sendJson(user, ar -> {
          if (ar.succeeded()) {
            System.out.println("Got HTTP response with status " + ar.result().statusCode());
            routingContext.response().setStatusCode(201).end("created");
          } else {
            ar.cause().printStackTrace();
          }
        });
    });

    vertx.createHttpServer().requestHandler(router).listen(3001, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("Consumer Verticle Server is Running " + httpServerAsyncResult.result().actualPort());
      }
    });

  }
}


public class WebClientMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WebClientMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ProviderVerticle());
    vertx.deployVerticle(new ConsumerVerticle());
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////

HTTP  + Event Bus :

let us assume i have apiverticle , communicated from users , receives data , send data to back end services.


package com.ibm.vertx.microservices.web.client;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

class Address {
  public final static String MESSAGE_ADDRESS = "ibm.alert";
}

//front end verticle
class HttpServerVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("http server ");
    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());
    router.get("/api/:message").handler(routingContext -> {
      String message = routingContext.request().getParam("message");
      //send message via event bus
      vertx.eventBus().send(Address.MESSAGE_ADDRESS, message);
      routingContext.response().end("message has been published");
    });
    vertx.createHttpServer().requestHandler(router).listen(3001, httpServerAsyncResult -> {
      if (httpServerAsyncResult.succeeded()) {
        System.out.println("Server is Running " + httpServerAsyncResult.result().actualPort());
      }
    });

  }
}

//back end service
class EventBusMessageVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Event bus message ");
    MessageConsumer<String> messageConsumer = vertx.eventBus().consumer(Address.MESSAGE_ADDRESS);
    messageConsumer.handler(message -> {
      System.out.println("Back end Service " + message.body());
    });
  }
}

public class EventBusHttpVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusHttpVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new HttpServerVerticle());
    vertx.deployVerticle(new EventBusMessageVerticle());
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////

Lab: Time 30 mins:
..................

Update existing Product REST APPLICATION as follows

1.Rest services code must be in "ProductHTTPVerticle"
2.Datbase logic code must be in  "ProductRepositoryVerticle"

client (postMan)----->ProductVerticle ------>ProductRepositoryVerticle

for eg if you ask product data,ProductRepositoryVerticle should return data via event...

////////////////////////////////////////////////////////////////////////////////////////////////////////

Vertx and Relational database:
..............................

JDBC is a technoloy through which you can connect relational databases.

JDBC works database independant , you can connect with any databases with help of jdbc driver.

now a days we are using orm frameworks -jpa,hibernate; orm internally uses jdbc only.

vertx as of no orm support. you have to write jdbc code only. jdbc is non blocking.

JDBC is nonblocking , so apis are callback based or reactive based.

Lets start coding:

1.you jdbc dependency.

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-jdbc-client</artifactId>
 <version>3.9.4</version>
</dependency>

2.database drivers dependency.

hsql db.

    <dependency>
      <groupId>org.hsqldb</groupId>
      <artifactId>hsqldb</artifactId>
      <version>2.3.4</version>
    </dependency>


api:
io.vertx.ext.jdbc
JDBCClient

1.create JDBCClient Object

   final JDBCClient client = JDBCClient.createShared(vertx, new JsonObject()
        .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
        .put("driver_class", "org.hsqldb.jdbcDriver")
        .put("max_pool_size", 30)
        .put("user", "SA")
        .put("password", ""));


2.You have to use callback chain pattern
   connection succcess
		|
		do sql operations
   else
    |
   throw Connection.

client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        
      } else {
        System.out.println(connection.cause());
      }
    });

3.Get SqlConnection instance
    client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();


      } else {
        System.out.println(connection.cause());
      }
    });


3.Table creation :
client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();
        String CREATE_TABLE = "create table test(id int primary key, name varchar(255))";
        con.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.failed()) {
            System.out.println(tableCreate.cause());
          } else {
            System.out.println("Tables are created");
            
          }

        });

      } else {
        System.out.println(connection.cause());
      }
    });

3.Table insert and select

client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();
        String CREATE_TABLE = "create table test(id int primary key, name varchar(255))";
        con.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.failed()) {
            System.out.println(tableCreate.cause());
          } else {
            System.out.println("Tables are created");

            String INSERT_QUERY = "insert into test values(1, 'Hello')";
            con.execute(INSERT_QUERY, tableInsert -> {

              if (tableInsert.failed()) {
                System.out.println(tableInsert.cause());
              } else {
                //show sample data; write select query
                String SELECT_QUERY = "select * from test";
                con.query(SELECT_QUERY, selectResult -> {
                  for (JsonArray line : selectResult.result().getResults()) {
                    System.out.println(line.encode());
                  }
                  // and close the connection
                  con.close(done -> {
                    if (done.failed()) {
                      throw new RuntimeException(done.cause());
                    }
                  });
                });
              }
            });
          }

        });


Full Code:
..........
package com.ibm.vertx.microservices.jdbc;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;

public class SimpleJDBC extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleJDBC.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    final JDBCClient client = JDBCClient.createShared(vertx, new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", ""));

    client.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("COnnection is ready");
        //get conneciton object
        final SQLConnection con = connection.result();
        String CREATE_TABLE = "create table test(id int primary key, name varchar(255))";
        con.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.failed()) {
            System.out.println(tableCreate.cause());
          } else {
            System.out.println("Tables are created");

            String INSERT_QUERY = "insert into test values(1, 'Hello')";
            con.execute(INSERT_QUERY, tableInsert -> {

              if (tableInsert.failed()) {
                System.out.println(tableInsert.cause());
              } else {
                //show sample data; write select query
                String SELECT_QUERY = "select * from test";
                con.query(SELECT_QUERY, selectResult -> {
                  for (JsonArray line : selectResult.result().getResults()) {
                    System.out.println(line.encode());
                  }
                  // and close the connection
                  con.close(done -> {
                    if (done.failed()) {
                      throw new RuntimeException(done.cause());
                    }
                  });
                });
              }
            });
          }

        });

      } else {
        System.out.println(connection.cause());
      }
    });

  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

Blocking code and Non blocking Code:
.....................................

Vertx has been designed to work with nonblocking.
 non blocking web apps,database,tcp,file system..............

Does vertx support blocking code and what if i write blocking code ?

Yes! blocking code, what if i write blocking inside verticles.

Use case : 

You are building vertx application, vertx application need to talk to hibernate/jpa layer.
Vertx is non blocking but hibernate blocking.

if you write blocking inside non blocking vertx will throw error, but how to bridge blocking with non-blocking.

Blocking code

-Thread.sleep
-long running task
-legacy file io
-legacy network 
-database 
-external api


 Any blocking code can't be executed inside event loop thread.
 Any blocking code must be executed in a separte threads - Worker pool threads.
 Worker pool threads are used for running long running blocking code.

There are many ways.

1.Change the verticle thread from event loop thread to worker pool thread
  These verticle are called worker verticles
2.via an blocking apis provided by vertx.


Worker Verticle is verticle to be used for running blocking code only so that event loop thread
never been stopped.


Event loop thread can wait for 2000ms - default wait duration : event loop thread in vertx cant 
wait / be blocked for 2000ms.


Types of Verticle:

1.standard Verticle
   Verticles are normal , executed by event loop thread
2.Woker verticles
   Verticles are special,executed by a separate thread of execution called "Worker poll threads".

How to create Worker Verticle?
 
Every Object in Vertx has its own configuration Object?


Eg:
HTTPServer instance has configuration object called HttpServerConfig
EventBus instance has configuration object called io.vertx.core.eventbus.DeliveryOptions
Vertx instance has configuration object Called VertxOptions
Verticle instance has configuration object Called - DeploymentOptions
...


How to configure a verticle before deployment?

io.vertx.core.DeploymentOptions


How to convert standard verticle into worker verticle?

public DeploymentOptions setWorker(boolean worker)
Set whether the verticle(s) should be deployed as a worker verticle.

Deploying Verticle with deployment options.


package com.ibm.vertx.microservices.blockingapis;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.example.util.Runner;

class BlockingCodeVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(Thread.currentThread().getName());
    //blocking code
    Thread.sleep(10000);
    System.out.println("timeout , my data is ready");
  }
}

public class BlockingApiVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingApiVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
//    DeploymentOptions deploymentOptions = new DeploymentOptions();
//    deploymentOptions.setWorker(true); //sets as a worker verticle
    DeploymentOptions deploymentOptions = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new BlockingCodeVerticle(), deploymentOptions);
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ibm.vertx.microservices.blockingapis;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class BlockingCodeVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.setTimer(1000, a -> {
      System.out.println("inside timer");
      System.out.println(Thread.currentThread().getName());
    });
    System.out.println(Thread.currentThread().getName());
    //blocking code
    Thread.sleep(10000);
    System.out.println("timeout , my data is ready");
  }
}

class BlockingAndNonBlocking extends AbstractVerticle {
  private void sayHello(Promise<String> promise) {
    System.out.println("Say Hello : " + Thread.currentThread().getName());
    try {
      Thread.sleep(4000);
      System.out.println("Wake Up for sending data to Non blocking Service");
      //this result will be accessed inside non blocking code
      promise.complete("Hey this is blocking Result");

    } catch (InterruptedException es) {
      promise.fail("Something went wrong in blocking service");
    }
  }

  //read result from blocking service
  private void resultHandler(AsyncResult<String> ar) {
    System.out.println("Result Handler" + Thread.currentThread().getName());
    if (ar.succeeded()) {
      System.out.println("Blocking api Result goes Ready Here");
      System.out.println(ar.result());
    } else {
      System.out.println(ar.cause().getMessage());
    }
  }

  //http handler
  public void httpAndBlocking() {
    Router router = Router.router(vertx);

    router.get("/api/nonblocking").handler(routingContext -> {
      System.out.println(Thread.currentThread().getName());
      routingContext.response().end("Non blocking Result");
    });
    //for writing blocking code and waits for blocking result and return back
    router.get("/api/blocking").blockingHandler(routingContext -> {
      //invoke blocking service like jpa calls..
      System.out.println(Thread.currentThread().getName());
      try {
        //blocking code
        Thread.sleep(5000);
        String blockingResult = "Blocking result";
        routingContext.response().end(blockingResult);
      } catch (Exception e) {

      }
    });
    vertx.createHttpServer().requestHandler(router).listen(3000, ar -> {
      if (ar.succeeded()) {
        System.out.println("Server is ready At " + ar.result().actualPort());
      }
    });
  }


  @Override
  public void start() throws Exception {
    super.start();
    vertx.executeBlocking(this::sayHello, this::resultHandler);
    httpAndBlocking();
  }
}


public class BlockingApiVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingApiVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
//    DeploymentOptions deploymentOptions = new DeploymentOptions();
//    deploymentOptions.setWorker(true); //sets as a worker verticle
    DeploymentOptions deploymentOptions = new DeploymentOptions().setWorker(true);
    //vertx.deployVerticle(new BlockingCodeVerticle(), deploymentOptions);

    vertx.deployVerticle(new BlockingAndNonBlocking());

  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////

Vertx Configuration :Distributed Configuration:
.........................

How to configure Vertx application:

Vert.x Config
  This component provides an extensible way to configure Vert.x applications.


Configuration Stores(Storage):
..............................

Physical storage:

1.files
2.directories -ldap....
3.HTTP Servers - a separate HTTP server.
4.Redis
5.System Properties
6.environment properties
7.In memory Store: Application memory

Configuration representation inisde vertx is json object.

Storage file formats:
1.yaml
2.json
3.properties
......

Verticle:
 -can read config  data from the Vertx Context Object / DeploymentOptions
 -can read config data  from the file via command line args
 -can read from any storage via Vertx-Config module objects like ConfigReteriver.


Use Case 1 :Application inmememory configuration.

How to supply configuration info to Verticle?


 -can read config  data from the Vertx Context Object
     via DeploymentOptions we need to inject config data.

-via DeploymentOptions while verticle is being deployed.

-How to read configuration which was supplied via DeploymentOptions

AbstractVerticle has an api 

public JsonObject config()
Get the configuration of the verticle.
This can be specified when the verticle is deployed.

Returns:
the configuration


Steps:

1.create DeploymentOptions Object

JsonObject config=new JsonObject().put("message","Hello");

DeploymentOptions  options=new DeploymentOptions();

options.setConfig(config);



package com.ibm.vertx.microservices.config;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

//
class ApplicationConfigVerticle extends AbstractVerticle {

  @Override
  public void start() throws Exception {
    super.start();
    //read config
    JsonObject config = config();
    System.out.println(config.encodePrettily());
    System.out.println(config().getString("name"));
    System.out.println(config().getString("message", "default Message"));

    vertx.createHttpServer()
      .requestHandler(request -> {
        request.response().end(config().getString("message", "You are lucky!!"));
      })
      .listen(config().getInteger("http.port", 3000));

  }
}


public class VerticleConfiguration extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(VerticleConfiguration.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    JsonObject serverConfig = new JsonObject()
      .put("http.port", 3000)
      .put("http.host", "locahost")
      .put("http.ssl", false);

    JsonObject applicationConfig = new JsonObject()
      .put("name", "Subramanian")
      .put("city", "Coimbatore")
      .put("state", "TN")
      .mergeIn(serverConfig);
    DeploymentOptions options = new DeploymentOptions();
    options.setConfig(applicationConfig);
    vertx.deployVerticle(new ApplicationConfigVerticle(), options, dep -> {
      if (dep.succeeded()) {
        System.out.println(dep.result());
      }
    });

  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////
Vert can read from Operating system env variables and system properties
System.out.println(System.getProperty("java.home"));
System.out.println(System.getProperty("path.separator"));
System.out.println(System.getenv("path"));


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

How to read configuration from external configuration system.
 
Configuration system could be file,dir,git......


1.ConfigRetriever:

  It configures a set of configuration store, where Configuration store defines  a location 
  from where the configuration data is read and also format(JSON by default).

 The Result from ConfigRetriever is JSON object.

Flow

  Application ------------------|ConfigRetriver----|ConfigStore
				JSON Object	<----	


How to instantiate the ConfigRetriver:

 ConfigRetriver retriver = ConfigRetriver.create(vertx).


Reading from json file:

Note: ConfigRetiver uses by default json file. if you read other than json  you need to extra depedencies.

Steps:

1.Add Dependency.

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-config</artifactId>
 <version>3.9.2</version>
</dependency>

2.create resources/config/config.json file

{
  "appname": "IBM Vertx Application",
  "version": "1.0.0"
}

3.set storage options
   ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));

4.Create ConfigReteriver

    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));

    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appname"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });


class ExternalConfigVerticle extends AbstractVerticle{
  @Override
  public void start() throws Exception {
    super.start();
    //store options
    ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));

    //config reteriver
    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));
    //read configuration
    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appname"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });

  }
}

How to read YAML files

Steps:

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-config-yaml</artifactId>
 <version>3.9.2</version>
</dependency>

ConfigStoreOptions store = new ConfigStoreOptions()
  .setType("file")
  .setFormat("yaml")
  .setConfig(new JsonObject()
    .put("path", "my-config.yaml")
  );

ConfigRetriever retriever = ConfigRetriever.create(vertx,
    new ConfigRetrieverOptions().addStore(store));

/////////////////////////////////////////////////////////////////////////////////////////////////////

package com.ibm.vertx.microservices.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class ExternalizeConfigVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(config().encodePrettily());
  }
}


class FileSystemConfigVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));
    ConfigRetriever retriever = ConfigRetriever.create(vertx,
      new ConfigRetrieverOptions().addStore(options));

    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appname"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });


  }
}

//
class ApplicationConfigVerticle extends AbstractVerticle {


  @Override
  public void start() throws Exception {
    super.start();
    //read config
    JsonObject config = config();
    System.out.println(config.encodePrettily());
    System.out.println(config().getString("name"));
    System.out.println(config().getString("message", "default Message"));

    vertx.createHttpServer()
      .requestHandler(request -> {
        request.response().end(config().getString("message", "You are lucky!!"));
      })
      .listen(config().getInteger("http.port", 3000));

    //env and system
    System.out.println(System.getProperty("java.home"));
    System.out.println(System.getProperty("path.separator"));
    System.out.println(System.getenv("path"));

  }
}


public class VerticleConfiguration extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(VerticleConfiguration.class);
  }

  public Future<JsonObject> getConfig() {
    Promise<JsonObject> promise = Promise.promise();
    //store options
    ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));
    //config reteriver
    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));
    //read configuration
    retriever.getConfig(config -> {
      if (config.succeeded()) {
        promise.complete(config.result());
      } else {
        promise.fail("Config Error : " + config.cause());
      }
    });
    return promise.future();

  }

  @Override
  public void start() throws Exception {
    super.start();
//    JsonObject serverConfig = new JsonObject()
//      .put("http.port", 3000)
//      .put("http.host", "locahost")
//      .put("http.ssl", false);
//
//    JsonObject applicationConfig = new JsonObject()
//      .put("name", "Subramanian")
//      .put("city", "Coimbatore")
//      .put("state", "TN")
//      .mergeIn(serverConfig);
//    DeploymentOptions options = new DeploymentOptions();
//    options.setConfig(applicationConfig);
//    vertx.deployVerticle(new ApplicationConfigVerticle(), options, dep -> {
//      if (dep.succeeded()) {
//        System.out.println(dep.result());
//      }
//    });
//
//    vertx.deployVerticle(new FileSystemConfigVerticle());

    //////////////////////////////////////////////////////////////////////
    getConfig().onSuccess(myconfig -> {
      //  System.out.println(myconfig.encodePrettily());
      JsonObject config = new JsonObject()
        .put("name", "Subramnaian")
        .put("message", "Hello!!")
        .put("port", 8082)
        .mergeIn(myconfig);
      DeploymentOptions myoptions = new DeploymentOptions().setConfig(config);
      vertx.deployVerticle(new ExternalizeConfigVerticle(), myoptions);
    });

  }
}
/////////////////////////////****************************//////////////////////////////////////////////

Distributed Vertx:
.................

As of now we have seen 
 -How to write verticle on single vertx engine
 -How verticles communicate using event bus on single vertx engine

Multi node architecture: Multi vertx engine architecuture:

Vertx Types:
...........

1.Standard Vertx
   -single vertx engine
2.Clustered Vertx
   -distributed vertx engine.

Clustering:

 Grouping  multiple different vertx engines  under one single communication system.
Kind of networking.we are making networking infrastructure among Vertx engins.

How many vertx engines can communcates?

Via Cluster Managers and Providers :

 Cluster Providers are third party servers, through vertx can communicates.


Vertx - Clustering:
...................

Clustering , means organization application under one communication channel.

Vertx uses integration/clustering technologies.

Vertx uses hazelcast ClusterManager/provider by default.

Cluster : group of something - group of verticles/vertx instance/jvm

in order to connect vertx apps across processes, we need cordinator 
-Bride softwares

Vertx can work with
-hazelcast
-apache zookeeper
-apache ignite
-apache Infinispan

ClusterManagers

by default, vertx has hazelcast, we dont need to configure by default.


ClusterManagers

by default, vertx has hazelcast, we dont need to configure by default.


How to enable clustering?

In vertx clustering can be enabled in two ways

1.through code

Vertx Configuration;

Types of vertx:
1.standard vertx
2.clusteredVertx

Vertx.createClusteredVertx()


2.through vertx command line

  vertx program.java -cluster


3.through Lanucher class as well


Vertx - Clustering:
...................

Clustering , means organization application under one communication channel.

Vertx uses integration/clustering technologies.

Vertx uses hazelcast ClusterManager/provider by default.

Cluster : group of something - group of verticles/vertx instance/jvm

in order to connect vertx apps across processes, we need cordinator 
-Bride softwares

Vertx can work with
-hazelcast
-apache zookeeper
-apache ignite
-apache Infinispan

ClusterManagers

by default, vertx has hazelcast, we dont need to configure by default.


How to enable clustering?

In vertx clustering can be enabled in two ways

1.through code

Vertx Configuration;

Types of vertx:
1.standard vertx
2.clusteredVertx

Vertx.createClusteredVertx()


2.through vertx command line

  vertx program.java -cluster


3.through Lanucher class as well


Steps for clustering:
....................

<dependency>
      <groupId>com.hazelcast</groupId>
      <artifactId>hazelcast</artifactId>
      <version>3.12.2</version>
</dependency>

Cluster Configuration:

two ways

1.through code

2.through configuration files
 -hazelcast uses file  cluster.xml

Create ClusteManager

Config hazelcastConfig = new Config();

// Now set some stuff on the config (omitted)

ClusterManager mgr = new HazelcastClusterManager(hazelcastConfig);



ClusterManager mgr = new HazelcastClusterManager(hazelcastConfig);

    ClusterManager mgr = new HazelcastClusterManager();
    
    VertxOptions options = new VertxOptions().setClusterManager(mgr);

    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {

       //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions();       
        
        vertxAsyncResult.result().deployVerticle("com.ibm.vertx.core.distributed.cluster.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

1.<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-hazelcast</artifactId>
 <version>3.9.3</version>
</dependency>

2.VertxOptions
  To configure vertx Engine.

C:\session\ibm\Aug\Vertx-Training\vertx-apps\src\main\java\ibm\vert\distribute\cluster>vertx run ConsumerVerticle.java -cluster


C:\session\ibm\Aug\Vertx-Training\vertx-apps\src\main\java\ibm\vert\distribute\cluster>vertx run PublisherVerticle.java -cluster


package com.ibm.vertx.microservices.distributed;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class ConsumerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();

    VertxOptions options = new VertxOptions().setClusterManager(mgr);

    Vertx.clusteredVertx(options, cluster -> {
      if (cluster.succeeded()) {
        DeploymentOptions deploymentOptions = new DeploymentOptions();
        cluster.result().deployVerticle("com.ibm.vertx.microservices.distributed.ConsumerVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });
      } else {
        System.out.println("Cluster up failed: " + cluster.cause());
      }
    });
  }

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
      String jvmName = runtimeBean.getName();
      System.out.println("Node  Name = " + jvmName);
      long pid = Long.valueOf(jvmName.split("@")[0]);
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      System.out.println("News 7's Today News : " + news.body());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}


package com.ibm.vertx.microservices.distributed;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class PublisherVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr);

    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {
        //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions();
        vertxAsyncResult.result().deployVerticle("com.ibm.vertx.microservices.distributed.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
    String jvmName = runtimeBean.getName();
    //processid
    long pid = Long.valueOf(jvmName.split("@")[0]);
    vertx.setPeriodic(5000, ar -> {
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India" + " From  " + jvmName;
      vertx.eventBus().publish("news.in.covid", news);
    });

  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

////////////////////////////////////////////////////////////////////////////////////////////////////

Use case : Highavailablity : scalling instances;



package com.ibm.vertx.microservices.distributed;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;

public class HighAvailabilityVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    HttpServer server = vertx.createHttpServer();

    server.requestHandler(req -> {
      long id = Thread.currentThread().getId();
      req.response().end("<h1> I am coming from " + id + " Instance " + instanceName);
    });

    server.listen(8888, "localhost", handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is Ready! " + Thread.currentThread().getId() + " " + instanceName);
      } else {
        System.out.println("Server failed to Start");
      }
    });
  }
}

How to run?
vertx run HighAvailabilityVerticle.java -instances=5



Via Code:
package com.ibm.vertx.microservices.distributed;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.http.HttpServer;
import io.vertx.example.util.Runner;

public class HighAvailablityDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HighAvailablityDeployer.class);
  }
  @Override
  public void start() throws Exception {
    super.start();
    DeploymentOptions options = new DeploymentOptions().setInstances(5);
    vertx.deployVerticle(HighAvailabilityVerticle.class.getName(), options);
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

High Availability and Fail-Over
Vert.x allows you to run your verticles with high availability (HA) support. In that case, when a vert.x instance running a verticle dies abruptly, the verticle is migrated to another vertx instance. The vert.x instances must be in the same cluster.

Automatic failover
When vert.x runs with HA enabled, if a vert.x instance where a verticle runs fails or dies, the verticle is redeployed automatically on another vert.x instance of the cluster. We call this verticle fail-over.

To run vert.x with the HA enabled, just add the -ha flag to the command line:

vertx run my-verticle.java -ha


Load balancing : Scalability
.................................................................................

what if the one verticle which was deployed down , due to various reasons.
What if the one verticle is not enough to handle load of clients.

You can scale noof  instance of Same Verticle.

You set no of instances of same the verticle .

Via Code

DeploymentOptions deploymentOptions = new DeploymentOptions().setInstances(5);

Note: No of instances can be set in cluster and non cluster mode

via commandline

vertx programname -cluster -instances=5

//ha - cluster + loadbalancing
vertx programname -ha -instances=5 


/////////////////////////////////////////////////////////////////////////////////////////////////////

cluster vs ha:

if you want only grouping or machines coordination use cluster
if you want grouping and failover use ha

////////////////////////////////////////////////////////////////////////////////////////////////////

Use case : Highavailablity : scalling instances;



package com.ibm.vertx.microservices.distributed;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;

public class HighAvailabilityVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    HttpServer server = vertx.createHttpServer();
    long instanceName = this.getClass().hashCode();

    server.requestHandler(req -> {
      long id = Thread.currentThread().getId();
      req.response().end("<h1> I am coming from " + id + " Instance " + instanceName);
    });

    server.listen(8888, "localhost", handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is Ready! " + Thread.currentThread().getId() + " " + instanceName);
      } else {
        System.out.println("Server failed to Start");
      }
    });
  }
}

How to run?
vertx run HighAvailabilityVerticle.java -instances=5



Via Code:
package com.ibm.vertx.microservices.distributed;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.http.HttpServer;
import io.vertx.example.util.Runner;

public class HighAvailablityDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HighAvailablityDeployer.class);
  }
  @Override
  public void start() throws Exception {
    super.start();
    DeploymentOptions options = new DeploymentOptions().setInstances(5);
    vertx.deployVerticle(HighAvailabilityVerticle.class.getName(), options);
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////

How to enable fail-over?

Steps: 

Open cmd  3 command prompt

1.vertx run ConsumerVerticle.java -ha -hagroup g1
2.vertx run PublisherVerticle.java -ha -hagroup g1
3.vertx bare -hagroup g1

stop publisher and see how fail over happens

Using 
Taskkill /PID 7100 /F

here 7100 process id of publisher.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Service Discovery and Registry:
..............................

Lookup server and naming server.

Data Base server which stores 'resources' :  web site address : dns server

Same concept is used in distributed programming/microservices:
-> RMI, EJB,DCOM

Why Service Registry?

 Registry is data base, used to store resources in centralized place.

The programs and applications  are located in networks , so it is difficult to locate/search resources.

Service discovery :

 The process of looking up resources, called service discovery.


Registry Server:
 It is key-value pair database, Where you can store and "lookup"  resources.


What we can store inside Registry Server in vertx?

 Resources:

Types of Resources(Services):
.............................
The services you can register into registry

HTTP Endpoint -HttpEndPoint.createRecord
Event Bus Service -EventBus.createRecord
Message Source
JDBC Data Source
Redis Data Source
MongoDb Data Source

Shared Data / Resource:

 In vertx you can store resources in centrialized place, and you share it across application.

eg: you have one jdbc connection, where you will store connection object, thats where shared data comes into picture.


Shared data architecture is "Service Discovery and Registry"

Implementation:

What you need?

1.Registry server- where you can store all shared resources(httpendpoint,jdbcconnection,eventbus...)

Vertx provides default built in Registry Server:
...............................................
-Key value data structure;
  Map- implementations.

Popular Registry Servers:
.........................
1.eureka server
2.Apache zoo keeper
3.Consule
4.Kubernetes
5.Redis
etc....


Core concepts:

1.Record - bag - inside bag you can store any resource-store that record into registry server.

Vertx Resource Storage:

Vertx resources are stored in side registry by packing resouces into a object called "Record".


Resource--->Record 

Service Discovery Objects:

1.Record
2.Service
3.ServiceDiscovery



Vertx has ServiceDiscovery Instance, which helps to publish / un publish ,and discover
services 


 Resource--->Record  ----| Discovery.publish(record)-----ZooKeeper

Operations:

1.Create Record
2.Wrap Resources into record
3.Publish Record into Regi	stry Server

4.1.Loopkup services via Discovery
4.2. Get Service instance
4.3.Use that Service instance

5.Unpublish the record from Registry Server.


<dependency>
   <groupId>io.vertx</groupId>
   <artifactId>vertx-service-discovery</artifactId>
   <version>3.9.2</version>
</dependency>

<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-service-discovery-backend-zookeeper</artifactId>
  <version>3.9.2</version>
</dependency>


Setup :

1.download registry server from https://zookeeper.apache.org/doc/current/zookeeperStarted.html#sc_Download

2.extract tar/zip file where ever the location

3.create conf/zoo.cfg  from conf/zoo_sample.cfg(by copy and paste)

4.Add the below entries

conf/zoo.cfg
tickTime=2000
dataDir=/var/lib/zookeeper
clientPort=2181

5.start zoo keeper server
  go to bin/ folder and excute zkServer.command /sh file


package com.ibm.vertx.microservices.servicediscovery;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.client.WebClient;
import io.vertx.servicediscovery.Record;
import io.vertx.servicediscovery.ServiceDiscovery;
import io.vertx.servicediscovery.ServiceDiscoveryOptions;
import io.vertx.servicediscovery.types.HttpEndpoint;

class MyServer extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.createHttpServer().requestHandler(request -> {
      if (request.path().equals("/api/hello")) {
        request.response().end("Hello");
      }
    }).listen(3000);
  }
}

class ConsumerVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    ServiceDiscoveryOptions discoveryOptions = new ServiceDiscoveryOptions();
    //enable discovery server : apache zoo keeper
    discoveryOptions.setBackendConfiguration(new JsonObject()
      .put("connection", "127.0.0.1:2181")
      .put("ephemeral", true)
      .put("guaranteed", true)
      .put("basePath", "/services/my-backend")
    );
    ServiceDiscovery discovery = ServiceDiscovery.create(vertx, discoveryOptions);

    //Record Creation,Record type is Resource Type;storing webclient Resource into registry
    Record httpEndPointRecord = HttpEndpoint.createRecord("myrecord", "localhost", 3000, "/api/hello");
    //publish the Record
    discovery.publish(httpEndPointRecord, ar -> {
      if (ar.succeeded()) {
        System.out.println("Successfully published ..>>>>" + ar.result().toJson());
      } else {
        System.out.println(" Not Published " + ar.cause());
      }
    });
    //lookup the resource
    vertx.setTimer(5000, ar -> {
      HttpEndpoint.getWebClient(discovery, new JsonObject().put("name", "myrecord"), sar -> {

        // get web client
        WebClient webClient = sar.result();
        webClient.get("/api/hello").send(res -> {
          System.out.println("Response is ready!");
          System.out.println(res.result().bodyAsString());
          //remove /release discovery record
          ServiceDiscovery.releaseServiceObject(discovery, webClient);
        });
      });
    });

  }
}


public class ServiceDiscoveryMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ServiceDiscoveryMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new MyServer());
    vertx.deployVerticle(new ConsumerVerticle());
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////

Resilience:
  How to handle failures,slow calls without affecting applicaiton work flow.

Reslience patterns:

1.Circuite Breakter pattern :
  fail fast pattern.


package com.ibm.vertx.microservices.resilence;

import io.vertx.circuitbreaker.CircuitBreaker;
import io.vertx.circuitbreaker.CircuitBreakerOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;

class SomeServiceVerticle extends AbstractVerticle {

  public void slowService() {
    vertx.createHttpServer().requestHandler(request -> {
      vertx.<String>executeBlocking(promise -> {
        // Do the blocking operation in here
        // Imagine this was a call to a blocking API to get the result
        try {
          Thread.sleep(5000);
        } catch (Exception ignore) {
        }
        String result = "hello , i am coming late , can you wait for me?";
        promise.complete(result);

      }, res -> {

        if (res.succeeded()) {
          request.response().putHeader("content-type", "text/plain").end(res.result());

        } else {
          res.cause().printStackTrace();
        }
      });

    }).listen(3000);
  }

  @Override
  public void start() throws Exception {
    super.start();
    slowService();
  }
}

public class CircuitBreakerPatternVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CircuitBreakerPatternVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new SomeServiceVerticle());

    CircuitBreakerOptions options = new CircuitBreakerOptions();
    options.setMaxFailures(2);// no of failures will be allowed , after that , ciruit will open
    options.setTimeout(3000); // consider a failure if the operation does not succeed in time
    options.setFallbackOnFailure(true); // if any failure, should i handle fallback or not
    options.setResetTimeout(5000); // time spent in open state before attempting to retry.

    CircuitBreaker circuitBreaker=CircuitBreaker.create("my-circuit-breaker", vertx, options);

    //call api with circuit breaker; risky code
    circuitBreaker.executeWithFallback(future -> {
      //risky code
      WebClient client = WebClient.create(vertx);
      client.get(3000, "localhost", "/").send(ar -> {
        // Obtain response
        HttpResponse<Buffer> response = ar.result();
        if (response.statusCode() != 200) {
          future.fail("HTTP error");
        } else {
          future.complete(response.bodyAsString());
        }
      });
    }, v -> {
      // Executed when the circuit is opened
      return "Hello, I am fallback";
    }).onComplete(ar -> {
      // Do something with the result
      if (ar.succeeded()) {
        System.out.println(ar.result());
      } else {
        System.out.println(ar.cause());

      }
    });


  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////


Reactive Extension with Vertx

Service Proxy.


Sample Project- from vertx Team.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Reactive Extension :
.....................
Vertx Programming Style:

1.future/promise - callback && Functional style 
2.Reactive Style -Using Rxjava
3.Hybrid Style = Future style + reactive Style

Reactive Programming in Vertx:
.............................

Vertx supports writing microservices and apps in reactive style , Reactive Microservice.

We have learned Rx java learned.

Most of the Apis can be rxified. Converting to RxType.

Why Reactive Programming?

  -enable Data streaming on which you can observe.

Rxjava powers Vertx by adding reactive extension on web,eventbus,webclient,............


eg:
if you take AbstractVerticle  which is coming from  io.vertx.core.AbstractVerticle
 -functional style verticle

///////////////////////////////////////////////////////////////////////////////////////////////////

Reactive Web Client:
package com.ibm.vertx.rx.webclient;

import io.reactivex.Single;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.ext.web.Router;
import io.vertx.reactivex.ext.web.RoutingContext;
import io.vertx.reactivex.ext.web.client.HttpRequest;
import io.vertx.reactivex.ext.web.client.HttpResponse;
import io.vertx.reactivex.ext.web.client.WebClient;
import io.vertx.reactivex.ext.web.codec.BodyCodec;

class HelloConsumerMicroservice extends AbstractVerticle {
  private WebClient client;

  @Override
  public void start() throws Exception {
    super.start();
    client = WebClient.create(vertx);

    Router router = Router.router(vertx);
    router.get("/").handler(this::invokeMyFirstMicroservice);

    vertx.createHttpServer()
      .requestHandler(router)
      .rxListen(8081).subscribe(
      httpServer -> System.out.println("Client is Running @ " + httpServer.actualPort()),
      error -> System.out.println(error)
    );
  }

  private void invokeMyFirstMicroservice(RoutingContext rc) {

    HttpRequest<JsonObject> request1 = client
      .get(8082, "localhost", "/Srisha")
      .as(BodyCodec.jsonObject());

    HttpRequest<JsonObject> request2 = client
      .get(8082, "localhost", "/Subramanian")
      .as(BodyCodec.jsonObject());

    Single<HttpResponse<JsonObject>> s1 = request1.rxSend();
    Single<HttpResponse<JsonObject>> s2 = request2.rxSend();

    Single.zip(s1, s2, (apiOne, apiTwo) -> {
      // We have the result of both request in Luke and Leia
      return new JsonObject()
        .put("firstName", apiOne.body().getString("message"))
        .put("lastName", apiTwo.body().getString("message"));
    }).subscribe(
      x -> {
        rc.response().end(x.encode());
      },
      t -> {
        rc.response().end(new JsonObject().encodePrettily());
      });
  }

}

class HelloMicroservice extends AbstractVerticle {
  @Override
  public void start() {
    Router router = Router.router(vertx);
    router.get("/").handler(this::hello);
    router.get("/:name").handler(this::hello);
    vertx.createHttpServer()
      .requestHandler(router)
      .rxListen(8082).subscribe(server -> {
      System.out.println("Provider is listening in " + server.actualPort());
    });
  }

  private void hello(RoutingContext rc) {
    String message = "hello";
    if (rc.pathParam("name") != null) {
      message += " " + rc.pathParam("name");
    }
    JsonObject json = new JsonObject().put("message", message);
    rc.response()
      .putHeader(HttpHeaders.CONTENT_TYPE, "application/json")
      .end(json.encode());
  }

}

public class WebClientReactiveMicroService extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WebClientReactiveMicroService.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.rxDeployVerticle(new HelloMicroservice())
      .subscribe(r -> System.out.println("HelloMicroservice deployed"));
    vertx.rxDeployVerticle(new HelloConsumerMicroservice())
      .subscribe(r -> System.out.println("HelloConsumerMicroservice deployed"));
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

Service Proxy:
.............
1.Cross language api access.
2.To separate biz logics from verticles.


<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-service-proxy</artifactId>
 <version>3.9.2</version>
</dependency>
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-codegen</artifactId>
 <version>3.9.2</version>
 <scope>compile</scope>
</dependency>

package com.ibm.vertx.services;

import io.vertx.codegen.annotations.Fluent;
import io.vertx.codegen.annotations.ProxyGen;
import io.vertx.codegen.annotations.VertxGen;
import io.vertx.core.*;
import io.vertx.example.util.Runner;
import io.vertx.serviceproxy.ServiceBinder;

/**
 * Service Proxy Interface
 * 1.annotate with two annotations
 * 2.we need unique event bus address: this interface is exposed via event only.
 * 3.we need to write biz apis.
 *    Rules;
 *      1.api must return void
 *      2.args must be Handler<AsyncResult<T>> handler
 *      3.extra data arg may be present
 *      4.if you want to return  type Can be interface type itself and must be annotated with
 * @Fluent
 * 4.you must have an api called
 *    static GreeterService createProxy(Vertx vertx, String address) {
 *     return new GreeterServiceVertxEBProxy(vertx, address);
 *   }
 *
 * @ProxyGen
 * @VertxGen
 */

@ProxyGen //generate proxy classes
@VertxGen //generate proxy classes for other languages
interface GreeterService {
  //unique event bus Address
  static String EVENTBUS_ADDRESS = GreeterService.class.getName();
  //api to create Service Proxy Object
  static GreeterService createProxy(Vertx vertx, String address) {
    return new GreeterServiceVertxEBProxy(vertx, address);
  }

  //biz apis
  void sayHello(String name, Handler<AsyncResult<String>> handler);

  @Fluent
  GreeterService doSomething();
}

class GreeterServiceImpl implements GreeterService {
  @Override
  public void sayHello(String name, Handler<AsyncResult<String>> handler) {
    handler.handle(Future.succeededFuture("Hello" + name));
  }

  @Override
  public GreeterService doSomething() {
    return this;
  }
}


class HaiVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    //Call service
    GreeterService service = GreeterService.createProxy(vertx, GreeterService.EVENTBUS_ADDRESS);

    service.sayHello("Subramanian", ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      }
    });
    service.doSomething().sayHello("Ram", ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      }
    });
  }
}
public class ServiceProxyMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ServiceProxyMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //Service Registeration
    GreeterService greeterService = new GreeterServiceImpl();
    new ServiceBinder(vertx).setAddress(GreeterService.EVENTBUS_ADDRESS).register(GreeterService.class, greeterService);

    //deploy
    vertx.deployVerticle(new HaiVerticle());

  }
}
pom.xml
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>${maven-compiler-plugin.version}</version>
        <configuration>
          <source>8</source>
          <target>8</target>
          <annotationProcessors>
            <annotationProcessor>io.vertx.codegen.CodeGenProcessor</annotationProcessor>
          </annotationProcessors>
        </configuration>
      </plugin>


# Extend vert.x image
FROM vertx/vertx3
#                                                       (1)
ENV VERTICLE_NAME com.ibm.vertx.containers.HelloVerticle
ENV VERTICLE_FILE target/vertx-apps-1.0.0-SNAPSHOT.jar

# Set the location of the verticles
ENV VERTICLE_HOME /usr/verticles

EXPOSE 8080

# Copy your verticle to the container                   (2)
COPY $VERTICLE_FILE $VERTICLE_HOME/

# Launch the verticle
WORKDIR $VERTICLE_HOME
ENTRYPOINT ["sh", "-c"]
CMD ["exec vertx run $VERTICLE_NAME -cp $VERTICLE_HOME/*"]


> docker build -t sample/vertx-java .

> docker run -t -i -p 8080:8080 sample/vertx-java

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&End&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&











